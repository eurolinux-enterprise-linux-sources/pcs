From a8252256ced2d32340b316d1e646f21511e995e0 Mon Sep 17 00:00:00 2001
From: Tomas Jelinek <tojeline@redhat.com>
Date: Fri, 27 Feb 2015 17:32:13 +0100
Subject: [PATCH 1/3] Warn if node removal will cause a loss of the quorum

---
 pcs/cluster.py         | 35 +++++++++++++++++++++++++++++++++++
 pcsd/pcs.rb            |  3 ++-
 pcsd/public/js/pcsd.js | 27 +++++++++++++++++++++++++--
 pcsd/remote.rb         | 11 +++++++++++
 4 files changed, 73 insertions(+), 3 deletions(-)

diff --git a/pcs/cluster.py b/pcs/cluster.py
index 35901d2..20d3bdc 100644
--- a/pcs/cluster.py
+++ b/pcs/cluster.py
@@ -1099,6 +1099,41 @@ def cluster_node(argv):
             print("Warning: Using udpu transport on a CMAN cluster, "
                 + "cluster restart is required to apply node addition")
     else:
+        if node0 not in utils.getNodesFromCorosyncConf():
+            utils.err(
+                "node '%s' does not appear to exist in configuration" % node0
+            )
+        if not "--force" in utils.pcs_options:
+            retval, data = utils.get_remote_quorumtool_output(node0)
+            if retval != 0:
+                utils.err(
+                    "Unable to determine whether removing the node will cause "
+                    + "a loss of the quorum, use --force to override\n"
+                    + data
+                )
+            # we are sure whether we are on cman cluster or not because only
+            # nodes from a local cluster can be stopped (see nodes validation
+            # above)
+            if utils.is_rhel6():
+                quorum_info = utils.parse_cman_quorum_info(data)
+            else:
+                quorum_info = utils.parse_quorumtool_output(data)
+            if quorum_info:
+                if utils.is_node_stop_cause_quorum_loss(
+                    quorum_info, local=False, node_list=[node0]
+                ):
+                    utils.err(
+                        "Removing the node will cause a loss of the quorum"
+                        + ", use --force to override"
+                    )
+            elif not utils.is_node_offline_by_quorumtool_output(data):
+                utils.err(
+                    "Unable to determine whether removing the node will cause "
+                    + "a loss of the quorum, use --force to override\n"
+                    + data
+                )
+            # else the node seems to be stopped already, we're ok to proceed
+
         nodesRemoved = False
         c_nodes = utils.getNodesFromCorosyncConf()
         destroy_cluster([node0])
diff --git a/pcsd/pcs.rb b/pcsd/pcs.rb
index 8e1dcb0..c322b9a 100644
--- a/pcsd/pcs.rb
+++ b/pcsd/pcs.rb
@@ -339,7 +339,8 @@ end
 
 def remove_node(new_nodename, all = false)
   if all
-    out, stderror, retval = run_cmd(PCS, "cluster", "node", "remove", new_nodename)
+    # we check for a quorum loss warning in remote_remove_nodes
+    out, stderror, retval = run_cmd(PCS, "cluster", "node", "remove", new_nodename, "--force")
   else
     out, stderror, retval = run_cmd(PCS, "cluster", "localnode", "remove", new_nodename)
   end
diff --git a/pcsd/public/js/pcsd.js b/pcsd/public/js/pcsd.js
index de0a939..ca85e3e 100644
--- a/pcsd/public/js/pcsd.js
+++ b/pcsd/public/js/pcsd.js
@@ -1026,11 +1026,14 @@ function remove_cluster(ids) {
   }
 }
 
-function remove_nodes(ids) {
+function remove_nodes(ids, force) {
   var data = {};
   for (var i=0; i<ids.length; i++) {
     data["nodename-"+i] = ids[i];
   }
+  if (force) {
+    data["force"] = force;
+  }
 
   $.ajax({
     type: 'POST',
@@ -1047,7 +1050,27 @@ function remove_nodes(ids) {
     },
     error: function (xhr, status, error) {
       $("#remove_node").dialog("close");
-      alert("Unable to remove nodes: " + res + " ("+error+")");
+      if ((status == "timeout") || ($.trim(error) == "timeout")) {
+        /*
+         We are not interested in timeout because:
+         - it can take minutes to stop a node (resources running on it have
+           to be stopped/moved and we do not need to wait for that)
+         - if pcs is not able to stop a node it returns an (forceable) error
+           immediatelly
+        */
+        return;
+      }
+      var message = "Unable to remove nodes (" + $.trim(error) + ")";
+      message += "\n" + xhr.responseText;
+      if (message.indexOf('--force') == -1) {
+        alert(message);
+      }
+      else {
+        message = message.replace(', use --force to override', '');
+        if (confirm(message + "\n\nDo you want to force the operation?")) {
+          remove_nodes(ids, true);
+        }
+      }
     }
   });
 }
diff --git a/pcsd/remote.rb b/pcsd/remote.rb
index 05f346d..7c4c790 100644
--- a/pcsd/remote.rb
+++ b/pcsd/remote.rb
@@ -444,16 +444,27 @@ def remote_remove_nodes(params)
   count = 0
   out = ""
   node_list = []
+  options = []
   while params["nodename-" + count.to_s]
     node_list << params["nodename-" + count.to_s]
     count = count + 1
   end
+  options << "--force" if params["force"]
 
   cur_node = get_current_node_name()
   if i = node_list.index(cur_node)
     node_list.push(node_list.delete_at(i))
   end
 
+  # stop the nodes at once in order to:
+  # - prevent resources from moving pointlessly
+  # - get possible quorum loss warning
+  stop_params = node_list + options
+  stdout, stderr, retval = run_cmd(PCS, "cluster", "stop", *stop_params)
+  if retval != 0
+    return [400, stderr.join]
+  end
+
   node_list.each {|node|
     retval, output = remove_node(node,true)
     out = out + output.join("\n")
-- 
1.9.1

