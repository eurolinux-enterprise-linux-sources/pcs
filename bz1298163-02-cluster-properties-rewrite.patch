From 171837304f7288d867a7a8d5eb0d5d4509d0628b Mon Sep 17 00:00:00 2001
From: Ondrej Mular <omular@redhat.com>
Date: Wed, 13 Jan 2016 12:39:24 +0100
Subject: [PATCH] cluster properties rewrite

 * property type validation in cli
 * full list of cluster settings in web UI
---
 pcs/pcs.8                      |    2 +-
 pcs/prop.py                    |  101 +++++++-----
 pcs/resource.py                |    2 +-
 pcs/test/pcs_test_functions.py |    4 +
 pcs/test/test_properties.py    |  210 +++++++++++++++++++++++++-
 pcs/test/test_utils.py         |  323 +++++++++++++++++++++++++++++++++-------
 pcs/usage.py                   |    2 +-
 pcs/utils.py                   |  237 ++++++++++++++++++++---------
 pcsd/pcs.rb                    |   40 +-----
 pcsd/pcsd.rb                   |  325 +++++++++++++++++++++-------------------
 pcsd/public/js/nodes-ember.js  |  162 ++++++++++++++++++--
 pcsd/public/js/pcsd.js         |   58 +++++++-
 pcsd/remote.rb                 |   85 +++++------
 pcsd/views/_configure.erb      |   44 ++++---
 pcsd/views/main.erb            |   37 +++++
 15 files changed, 1182 insertions(+), 450 deletions(-)

diff --git a/pcs/pcs.8 b/pcs/pcs.8
index f0d0724..cc5b4aa 100644
--- a/pcs/pcs.8
+++ b/pcs/pcs.8
@@ -390,7 +390,7 @@ Remove the permission id specified (permission id's are listed in parenthesis af
 list|show [<property> | \fB\-\-all\fR | \fB\-\-defaults\fR]
 List property settings (default: lists configured properties).  If \fB\-\-defaults\fR is specified will show all property defaults, if \fB\-\-all\fR is specified, current configured properties will be shown with unset properties and their defaults.  Run 'man pengine' and 'man crmd' to get a description of the properties.
 .TP
-set [\fB\-\-force\fR] [\fB\-\-node\fR <nodename>] <property>=[<value>]
+set [\fB\-\-force\fR] [\fB\-\-node\fR <nodename>] <property>=[<value>] ...
 Set specific pacemaker properties (if the value is blank then the property is removed from the configuration).  If a property is not recognized by pcs the property will not be created unless the \fB\-\-force\fR is used. If \fB\-\-node\fR is used a node attribute is set on the specified node.  Run 'man pengine' and 'man crmd' to get a description of the properties.
 .TP
 unset [\fB\-\-node\fR <nodename>] <property>
diff --git a/pcs/prop.py b/pcs/prop.py
index 592e4d8..ea33350 100644
--- a/pcs/prop.py
+++ b/pcs/prop.py
@@ -4,44 +4,81 @@ from __future__ import print_function
 from __future__ import unicode_literals
 
 import sys
+import json
 from xml.dom.minidom import parseString
-import xml.etree.ElementTree as ET
 
 import usage
 import utils
-import settings
 
 def property_cmd(argv):
     if len(argv) == 0:
         argv = ["list"]
 
     sub_cmd = argv.pop(0)
-    if (sub_cmd == "help"):
+    if sub_cmd == "help":
         usage.property(argv)
-    elif (sub_cmd == "set"):
+    elif sub_cmd == "set":
         set_property(argv)
-    elif (sub_cmd == "unset"):
+    elif sub_cmd == "unset":
         unset_property(argv)
-    elif (sub_cmd == "list" or sub_cmd == "show"):
+    elif sub_cmd == "list" or sub_cmd == "show":
         list_property(argv)
+    elif sub_cmd == "get_cluster_properties_definition":
+        print(json.dumps(utils.get_cluster_properties_definition()))
     else:
         usage.property()
         sys.exit(1)
 
+
 def set_property(argv):
+    prop_def_dict = utils.get_cluster_properties_definition()
+    nodes_attr = "--node" in utils.pcs_options
+    failed = False
+    forced = "--force" in utils.pcs_options
+    properties = {}
     for arg in argv:
         args = arg.split('=')
-        if (len(args) != 2):
-            print("Invalid Property: " + arg)
-            continue
-        if "--node" in utils.pcs_options:
-            utils.set_node_attribute(args[0], args[1], utils.pcs_options["--node"])
-        elif ("--force" in utils.pcs_options) or utils.is_valid_property(args[0]):
-            if not args[0]:
-                utils.err("property name cannot be empty")
-            utils.set_cib_property(args[0],args[1])
+        if len(args) != 2:
+            utils.err("invalid property format: '{0}'".format(arg), False)
+            failed = True
+        elif not args[0]:
+            utils.err("empty property name: '{0}'".format(arg), False)
+            failed = True
+        elif nodes_attr or forced or args[1].strip() == "":
+            properties[args[0]] = args[1]
         else:
-            utils.err("unknown cluster property: '%s', (use --force to override)" % args[0])
+            try:
+                if utils.is_valid_cluster_property(
+                    prop_def_dict, args[0], args[1]
+                ):
+                    properties[args[0]] = args[1]
+                else:
+                    utils.err(
+                        "invalid value of property: '{0}', (use --force to "
+                        "override)".format(arg),
+                        False
+                    )
+                    failed = True
+            except utils.UnknownPropertyException:
+                utils.err(
+                    "unknown cluster property: '{0}', (use --force to "
+                    "override)".format(args[0]),
+                    False
+                )
+                failed = True
+
+    if failed:
+        sys.exit(1)
+
+    if nodes_attr:
+        for prop, value in properties.items():
+            utils.set_node_attribute(prop, value, utils.pcs_options["--node"])
+    else:
+        cib_dom = utils.get_cib_dom()
+        for prop, value in properties.items():
+            utils.set_cib_property(prop, value, cib_dom)
+        utils.replace_cib_configuration(cib_dom)
+
 
 def unset_property(argv):
     if len(argv) < 1:
@@ -52,8 +89,10 @@ def unset_property(argv):
         for arg in argv:
             utils.set_node_attribute(arg, "",utils.pcs_options["--node"])
     else:
+        cib_dom = utils.get_cib_dom()
         for arg in argv:
-            utils.set_cib_property(arg, "")
+            utils.set_cib_property(arg, "", cib_dom)
+        utils.replace_cib_configuration(cib_dom)
 
 def list_property(argv):
     print_all = False
@@ -87,32 +126,10 @@ def list_property(argv):
             print(" ".join(line_parts))
 
 def get_default_properties():
-    (output, retVal) = utils.run([settings.pengine_binary, "metadata"])
-    if retVal != 0:
-        utils.err("unable to get pengine metadata\n"+output)
-    pe_root = ET.fromstring(output)
-
-    (output, retVal) = utils.run([settings.crmd_binary, "metadata"])
-    if retVal != 0:
-        utils.err("unable to get crmd metadata\n"+output)
-    crmd_root = ET.fromstring(output)
-    
-    (output, retVal) = utils.run([settings.cib_binary, "metadata"])
-    if retVal != 0:
-        utils.err("unable to get cib metadata\n"+output)
-    cib_root = ET.fromstring(output)
-
     parameters = {}
-    for root in [pe_root, crmd_root, cib_root]:
-        for param in root.getiterator('parameter'):
-            name = param.attrib["name"]
-            content = param.find("content")
-            if content is not None:
-                default = content.attrib["default"]
-            else:
-                default = ""
-
-            parameters[name] =  default
+    prop_def_dict = utils.get_cluster_properties_definition()
+    for name, prop in prop_def_dict.items():
+        parameters[name] = prop["default"]
     return parameters
 
 def get_set_properties(prop_name=None, defaults=None):
diff --git a/pcs/resource.py b/pcs/resource.py
index 89e7ac9..5c9fce9 100644
--- a/pcs/resource.py
+++ b/pcs/resource.py
@@ -2618,7 +2618,7 @@ def resource_relocate_set_stickiness(cib_dom, resources=None):
                 meta_attributes = utils.dom_prepare_child_element(
                     res_or_child,
                     "meta_attributes",
-                    res_or_child.getAttribute("id") + "-"
+                    res_or_child.getAttribute("id") + "-meta_attributes"
                 )
                 utils.dom_update_nv_pair(
                     meta_attributes,
diff --git a/pcs/usage.py b/pcs/usage.py
index c4ef564..db00334 100644
--- a/pcs/usage.py
+++ b/pcs/usage.py
@@ -885,7 +885,7 @@ Commands:
         properties and their defaults.
         Run 'man pengine' and 'man crmd' to get a description of the properties.
 
-    set [--force] [--node <nodename>] <property>=[<value>]
+    set [--force] [--node <nodename>] <property>=[<value>] ...
         Set specific pacemaker properties (if the value is blank then the
         property is removed from the configuration).  If a property is not
         recognized by pcs the property will not be created unless the
diff --git a/pcs/utils.py b/pcs/utils.py
index 05afa76..554dcdd 100644
--- a/pcs/utils.py
+++ b/pcs/utils.py
@@ -66,6 +66,12 @@ fence_bin = settings.fence_agent_binaries
 
 score_regexp = re.compile(r'^[+-]?((INFINITY)|(\d+))$')
 
+CIB_BOOLEAN_TRUE = ["true", "on", "yes", "y", "1"]
+CIB_BOOLEAN_FALSE = ["false", "off", "no", "n", "0"]
+
+class UnknownPropertyException(Exception):
+    pass
+
 def simple_cache(func):
     cache = {}
     def wrapper(*args):
@@ -1550,43 +1556,6 @@ def set_unmanaged(resource):
             "is-managed", "--meta", "--parameter-value", "false"]
     return run(args)
 
-def is_valid_property(prop):
-    output, retval = run([settings.pengine_binary, "metadata"])
-    if retval != 0:
-        err("unable to run pengine\n" + output)
-
-# whitelisted properties
-    if prop in ["enable-acl"]:
-        return True
-
-    dom = parseString(output)
-    properties = dom.getElementsByTagName("parameter");
-    for p in properties:
-        if p.getAttribute("name") == prop:
-            return True
-
-    output, retval = run([settings.crmd_binary, "metadata"])
-    if retval != 0:
-        err("unable to run crmd\n" + output)
-
-    dom = parseString(output)
-    properties = dom.getElementsByTagName("parameter");
-    for p in properties:
-        if p.getAttribute("name") == prop:
-            return True
-
-    output, retval = run([settings.cib_binary, "metadata"])
-    if retval != 0:
-        err("unable to run cib\n" + output)
-
-    dom = parseString(output)
-    properties = dom.getElementsByTagName("parameter");
-    for p in properties:
-        if p.getAttribute("name") == prop:
-            return True
-
-    return False
-
 def get_node_attributes():
     node_config = get_cib_xpath("//nodes")
     nas = {}
@@ -1622,39 +1591,36 @@ def set_node_attribute(prop, value, node):
 
 # If the property exists, remove it and replace it with the new property
 # If the value is blank, then we just remove it
-def set_cib_property(prop, value):
-    crm_config = get_cib_xpath("//crm_config")
-    if (crm_config == ""):
-        err("unable to get crm_config, is pacemaker running?")
-    property_found = False
-    document = parseString(crm_config)
-    crm_config = document.documentElement
-    cluster_property_set = crm_config.getElementsByTagName("cluster_property_set")
-    if len(cluster_property_set) == 0:
-        cluster_property_set = document.createElement("cluster_property_set")
-        cluster_property_set.setAttribute("id", "cib-bootstrap-options")
-        crm_config.appendChild(cluster_property_set) 
+def set_cib_property(prop, value, cib_dom=None):
+    update_cib = cib_dom is None
+    if update_cib:
+        crm_config = get_cib_xpath("//crm_config")
+        if crm_config == "":
+            err("unable to get crm_config, is pacemaker running?")
+        crm_config = parseString(crm_config).documentElement
     else:
-        cluster_property_set = cluster_property_set[0]
+        document = cib_dom.getElementsByTagName("crm_config")
+        if len(document) == 0:
+            err("unable to get crm_config, is pacemaker running?")
+        crm_config = document[0]
+
+    property_found = False
+    cluster_property_set = dom_prepare_child_element(
+        crm_config, "cluster_property_set", "cib-bootstrap-options"
+    )
+
     for child in cluster_property_set.getElementsByTagName("nvpair"):
-        if (child.nodeType != xml.dom.minidom.Node.ELEMENT_NODE):
-            break
-        if (child.getAttribute("name") == prop):
-            child.parentNode.removeChild(child)
+        if child.getAttribute("name") == prop:
             property_found = True
             break
+    if not property_found and value == "" and "--force" not in pcs_options:
+        err("can't remove property: '{0}' that doesn't exist".format(prop))
+    dom_update_nv_pair(
+        cluster_property_set, prop, value, "cib-bootstrap-options-"
+    )
 
-# If the value is empty we don't add it to the cluster
-    if value != "":
-        new_property = document.createElement("nvpair")
-        new_property.setAttribute("id","cib-bootstrap-options-"+prop)
-        new_property.setAttribute("name",prop)
-        new_property.setAttribute("value",value)
-        cluster_property_set.appendChild(new_property)
-    elif not property_found and "--force" not in pcs_options:
-        err("can't remove property: '%s' that doesn't exist" % (prop))
-
-    replace_cib_configuration(crm_config)
+    if update_cib:
+        replace_cib_configuration(crm_config)
 
 def setAttribute(a_type, a_name, a_value):
     args = ["crm_attribute", "--type", a_type, "--attr-name", a_name,
@@ -2018,7 +1984,10 @@ def verify_cert_key_pair(cert, key):
 # Does pacemaker consider a variable as true in cib?
 # See crm_is_true in pacemaker/lib/common/utils.c
 def is_cib_true(var):
-    return var.lower() in ("true", "on", "yes", "y", "1")
+    return var.lower() in CIB_BOOLEAN_TRUE
+
+def is_cib_boolean(val):
+    return val.lower() in CIB_BOOLEAN_TRUE + CIB_BOOLEAN_FALSE
 
 def is_systemctl():
     systemctl_paths = [
@@ -2334,7 +2303,7 @@ def is_node_stop_cause_quorum_loss(quorum_info, local=True, node_list=None):
         votes_after_stop += node_info["votes"]
     return votes_after_stop < quorum_info["quorum"]
 
-def dom_prepare_child_element(dom_element, tag_name, id_prefix=""):
+def dom_prepare_child_element(dom_element, tag_name, id):
     dom = dom_element.ownerDocument
     child_elements = []
     for child in dom_element.childNodes:
@@ -2343,9 +2312,7 @@ def dom_prepare_child_element(dom_element, tag_name, id_prefix=""):
 
     if len(child_elements) == 0:
         child_element = dom.createElement(tag_name)
-        child_element.setAttribute(
-            "id", id_prefix + tag_name
-        )
+        child_element.setAttribute("id", find_unique_id(dom, id))
         dom_element.appendChild(child_element)
     else:
         child_element = child_elements[0]
@@ -2391,7 +2358,7 @@ def dom_update_utilization(dom_element, attributes, id_prefix=""):
     utilization = dom_prepare_child_element(
         dom_element,
         "utilization",
-        id_prefix + dom_element.getAttribute("id") + "-"
+        id_prefix + dom_element.getAttribute("id") + "-utilization"
     )
 
     for name, value in attributes:
@@ -2409,7 +2376,9 @@ def dom_update_utilization(dom_element, attributes, id_prefix=""):
 
 def dom_update_meta_attr(dom_element, attributes):
     meta_attributes = dom_prepare_child_element(
-        dom_element, "meta_attributes", dom_element.getAttribute("id") + "-"
+        dom_element,
+        "meta_attributes",
+        dom_element.getAttribute("id") + "-meta_attributes"
     )
 
     for name, value in attributes:
@@ -2437,3 +2406,127 @@ def get_utilization_str(element):
     for name, value in sorted(get_utilization(element).items()):
         output.append(name + "=" + value)
     return " ".join(output)
+
+def is_valid_cluster_property(prop_def_dict, property, value):
+    if property not in prop_def_dict:
+        raise UnknownPropertyException(
+            "unknown cluster property: '{0}'".format(property)
+        )
+    return is_valid_cib_value(
+        prop_def_dict[property]["type"],
+        value,
+        prop_def_dict[property].get("enum", [])
+    )
+
+
+def is_valid_cib_value(type, value, enum_options=[]):
+    type = type.lower()
+    if type == "enum":
+        return value in enum_options
+    elif type == "boolean":
+        return is_cib_boolean(value)
+    elif type == "integer":
+        return is_score(value)
+    elif type == "time":
+        return get_timeout_seconds(value) is not None
+    else:
+        return True
+
+
+def get_cluster_property_default(prop_def_dict, prop):
+    if prop not in prop_def_dict:
+        raise UnknownPropertyException(
+            "unknown cluster property: '{0}'".format(prop)
+        )
+    return prop_def_dict[prop]["default"]
+
+
+def get_cluster_properties_definition():
+    # we don't want to change these properties
+    banned_props = ["dc-version", "cluster-infrastructure"]
+    basic_props = [
+        "batch-limit", "no-quorum-policy", "symmetric-cluster", "enable-acl",
+        "stonith-enabled", "stonith-action", "pe-input-series-max",
+        "stop-orphan-resources", "stop-orphan-actions", "cluster-delay",
+        "start-failure-is-fatal", "pe-error-series-max", "pe-warn-series-max"
+        ]
+    readable_names = {
+        "batch-limit": "Batch Limit",
+        "no-quorum-policy": "No Quorum Policy",
+        "symmetric-cluster": "Symmetric",
+        "stonith-enabled": "Stonith Enabled",
+        "stonith-action": "Stonith Action",
+        "cluster-delay": "Cluster Delay",
+        "stop-orphan-resources": "Stop Orphan Resources",
+        "stop-orphan-actions": "Stop Orphan Actions",
+        "start-failure-is-fatal": "Start Failure is Fatal",
+        "pe-error-series-max": "PE Error Storage",
+        "pe-warn-series-max": "PE Warning Storage",
+        "pe-input-series-max": "PE Input Storage",
+        "enable-acl": "Enable ACLs"
+    }
+    sources = [
+        {
+            "name": "pengine",
+            "path": settings.pengine_binary
+        },
+        {
+            "name": "crmd",
+            "path": settings.crmd_binary
+        },
+        {
+            "name": "cib",
+            "path": settings.cib_binary
+        }
+    ]
+    definition = {}
+    for source in sources:
+        output, retval = run([source["path"], "metadata"])
+        if retval != 0:
+            err("unable to run {0}\n".format(source["name"]) + output)
+        etree = ET.fromstring(output)
+        for e in etree.findall("./parameters/parameter"):
+            prop = get_cluster_property_from_xml(e)
+            if prop["name"] not in banned_props:
+                prop["source"] = source["name"]
+                prop["advanced"] = prop["name"] not in basic_props
+                if prop["name"] in readable_names:
+                    prop["readable_name"] = readable_names[prop["name"]]
+                else:
+                    prop["readable_name"] = prop["name"]
+                definition[prop["name"]] = prop
+    return definition
+
+
+def get_cluster_property_from_xml(etree_el):
+    property = {
+        "name": etree_el.get("name"),
+        "shortdesc": etree_el.find("shortdesc").text,
+        "longdesc": etree_el.find("longdesc").text
+    }
+    if property["shortdesc"] is None:
+        property["shortdesc"] = ""
+    if property["longdesc"] is None:
+        property["longdesc"] = ""
+
+    content = etree_el.find("content")
+    if content is None:
+        property["type"] = ""
+        property["default"] = ""
+    else:
+        property["type"] = content.get("type", "")
+        property["default"] = content.get("default", "")
+
+    if property["type"] == "enum":
+        property["enum"] = []
+        if property["longdesc"]:
+            values = property["longdesc"].split("  Allowed values: ")
+            if len(values) == 2:
+                property["enum"] = values[1].split(", ")
+                property["longdesc"] = values[0]
+        if property["default"] not in property["enum"]:
+            property["enum"].append(property["default"])
+
+    if property["longdesc"] == property["shortdesc"]:
+        property["longdesc"] = ""
+    return property
diff --git a/pcsd/pcs.rb b/pcsd/pcs.rb
index 2f58502..2d7179b 100644
--- a/pcsd/pcs.rb
+++ b/pcsd/pcs.rb
@@ -20,42 +20,13 @@ def getAllSettings(session, cib_dom=nil)
   unless cib_dom
     cib_dom = get_cib_dom(session)
   end
-  stdout2, stderr2, retval2 = run_cmd(session, PENGINE, "metadata")
-  metadata = stdout2.join
   ret = {}
-  if cib_dom and retval2 == 0
-    doc = REXML::Document.new(metadata)
-
-    default = ""
-    el_type = ""
-    doc.elements.each("resource-agent/parameters/parameter") { |e|
-      name = e.attributes["name"]
-      name.gsub!(/-/,"_")
-      e.elements.each("content") { |c|
-        default = c.attributes["default"]
-        el_type = c.attributes["type"]
-      }
-      ret[name] = {"value" => default, "type" => el_type}
-    }
-
+  if cib_dom
     cib_dom.elements.each('/cib/configuration/crm_config//nvpair') { |e|
-      key = e.attributes['name']
-      val = e.attributes['value']
-      key.gsub!(/-/,"_")
-      if ret.has_key?(key)
-        if ret[key]["type"] == "boolean"
-          val == "true" ?  ret[key]["value"] = true : ret[key]["value"] = false
-        else
-          ret[key]["value"] = val
-        end
-
-      else
-        ret[key] = {"value" => val, "type" => "unknown"}
-      end
+      ret[e.attributes['name']] = e.attributes['value']
     }
-    return ret
   end
-  return {"error" => "Unable to get configuration settings"}
+  return ret
 end
 
 def add_fence_level(session, level, devices, node, remove = false)
@@ -1688,10 +1659,7 @@ def get_node_status(session, cib_dom)
     node_status[:constraints] = getAllConstraints(cib_dom.elements['/cib/configuration/constraints'])
   end
 
-  cluster_settings = getAllSettings(session, cib_dom)
-  if not cluster_settings.has_key?('error')
-    node_status[:cluster_settings] = cluster_settings
-  end
+  node_status[:cluster_settings] = getAllSettings(session, cib_dom)
 
   return node_status
 end
diff --git a/pcsd/pcsd.rb b/pcsd/pcsd.rb
index a4f6bab..238861c 100644
--- a/pcsd/pcsd.rb
+++ b/pcsd/pcsd.rb
@@ -434,8 +434,6 @@ if not DISABLE_GUI
     end
     @resource_agents = get_resource_agents_avail(session)
     @stonith_agents = get_stonith_agents_avail(session)
-    @config_options = getConfigOptions2(session, @nodes)
-
     erb :nodes, :layout => :main
   end
 
@@ -451,6 +449,179 @@ if not DISABLE_GUI
     overview_cluster(params, request, session)
   end
 
+  get '/managec/:cluster/cluster_properties' do
+    cluster = params[:cluster]
+    unless cluster
+      return 200, {}
+    end
+    code, out = send_cluster_request_with_token(session, cluster, 'get_cib')
+    if code == 403
+      return [403, 'Permission denied']
+    elsif code != 200
+      return [400, 'getting CIB failed']
+    end
+    begin
+      properties = getAllSettings(nil, REXML::Document.new(out))
+      code, out = send_cluster_request_with_token(
+        session, cluster, 'get_cluster_properties_definition'
+      )
+
+      if code == 403
+        return [403, 'Permission denied']
+      elsif code == 404
+        definition = {
+          'batch-limit' => {
+            'name' => 'batch-limit',
+            'source' => 'pengine',
+            'default' => '0',
+            'type' => 'integer',
+            'shortdesc' => 'The number of jobs that pacemaker is allowed to execute in parallel.',
+            'longdesc' => 'The "correct" value will depend on the speed and load of your network and cluster nodes.',
+            'readable_name' => 'Batch Limit',
+            'advanced' => false
+          },
+          'no-quorum-policy' => {
+            'name' => 'no-quorum-policy',
+            'source' => 'pengine',
+            'default' => 'stop',
+            'type' => 'enum',
+            'enum' => ['stop', 'freeze', 'ignore', 'suicide'],
+            'shortdesc' => 'What to do when the cluster does not have quorum.',
+            'longdesc' => 'Allowed values:
+    * ignore - continue all resource management
+    * freeze - continue resource management, but don\'t recover resources from nodes not in the affected partition
+    * stop - stop all resources in the affected cluster partition
+    * suicide - fence all nodes in the affected cluster partition',
+            'readable_name' => 'No Quorum Policy',
+            'advanced' => false
+          },
+          'symmetric-cluster' => {
+            'name' => 'symmetric-cluster',
+            'source' => 'pengine',
+            'default' => 'true',
+            'type' => 'boolean',
+            'shortdesc' => 'All resources can run anywhere by default.',
+            'longdesc' => 'All resources can run anywhere by default.',
+            'readable_name' => 'Symmetric',
+            'advanced' => false
+          },
+          'stonith-enabled' => {
+            'name' => 'stonith-enabled',
+            'source' => 'pengine',
+            'default' => 'true',
+            'type' => 'boolean',
+            'shortdesc' => 'Failed nodes are STONITH\'d',
+            'longdesc' => 'Failed nodes are STONITH\'d',
+            'readable_name' => 'Stonith Enabled',
+            'advanced' => false
+          },
+          'stonith-action' => {
+            'name' => 'stonith-action',
+            'source' => 'pengine',
+            'default' => 'reboot',
+            'type' => 'enum',
+            'enum' => ['reboot', 'poweroff', 'off'],
+            'shortdesc' => 'Action to send to STONITH device',
+            'longdesc' => 'Action to send to STONITH device Allowed values: reboot, poweroff, off',
+            'readable_name' => 'Stonith Action',
+            'advanced' => false
+          },
+          'cluster-delay' => {
+            'name' => 'cluster-delay',
+            'source' => 'pengine',
+            'default' => '60s',
+            'type' => 'time',
+            'shortdesc' => 'Round trip delay over the network (excluding action execution)',
+            'longdesc' => 'The "correct" value will depend on the speed and load of your network and cluster nodes.',
+            'readable_name' => 'Cluster Delay',
+            'advanced' => false
+          },
+          'stop-orphan-resources' => {
+            'name' => 'stop-orphan-resources',
+            'source' => 'pengine',
+            'default' => 'true',
+            'type' => 'boolean',
+            'shortdesc' => 'Should deleted resources be stopped',
+            'longdesc' => 'Should deleted resources be stopped',
+            'readable_name' => 'Stop Orphan Resources',
+            'advanced' => false
+          },
+          'stop-orphan-actions' => {
+            'name' => 'stop-orphan-actions',
+            'source' => 'pengine',
+            'default' => 'true',
+            'type' => 'boolean',
+            'shortdesc' => 'Should deleted actions be cancelled',
+            'longdesc' => 'Should deleted actions be cancelled',
+            'readable_name' => 'top Orphan Actions',
+            'advanced' => false
+          },
+          'start-failure-is-fatal' => {
+            'name' => 'start-failure-is-fatal',
+            'source' => 'pengine',
+            'default' => 'true',
+            'type' => 'boolean',
+            'shortdesc' => 'Always treat start failures as fatal',
+            'longdesc' => 'This was the old default. However when set to FALSE, the cluster will instead use the resource\'s failcount and value for resource-failure-stickiness',
+            'readable_name' => 'Start Failure is Fatal',
+            'advanced' => false
+          },
+          'pe-error-series-max' => {
+            'name' => 'pe-error-series-max',
+            'source' => 'pengine',
+            'default' => '-1',
+            'type' => 'integer',
+            'shortdesc' => 'The number of PE inputs resulting in ERRORs to save',
+            'longdesc' => 'Zero to disable, -1 to store unlimited.',
+            'readable_name' => 'PE Error Storage',
+            'advanced' => false
+          },
+          'pe-warn-series-max' => {
+            'name' => 'pe-warn-series-max',
+            'source' => 'pengine',
+            'default' => '5000',
+            'type' => 'integer',
+            'shortdesc' => 'The number of PE inputs resulting in WARNINGs to save',
+            'longdesc' => 'Zero to disable, -1 to store unlimited.',
+            'readable_name' => 'PE Warning Storage',
+            'advanced' => false
+          },
+          'pe-input-series-max' => {
+            'name' => 'pe-input-series-max',
+            'source' => 'pengine',
+            'default' => '4000',
+            'type' => 'integer',
+            'shortdesc' => 'The number of other PE inputs to save',
+            'longdesc' => 'Zero to disable, -1 to store unlimited.',
+            'readable_name' => 'PE Input Storage',
+            'advanced' => false
+          },
+          'enable-acl' => {
+            'name' => 'enable-acl',
+            'source' => 'cib',
+            'default' => 'false',
+            'type' => 'boolean',
+            'shortdesc' => 'Enable CIB ACL',
+            'longdesc' => 'Should pacemaker use ACLs to determine access to cluster',
+            'readable_name' => 'Enable ACLs',
+            'advanced' => false
+          },
+        }
+      elsif code != 200
+        return [400, 'getting properties definition failed']
+      else
+        definition = JSON.parse(out)
+      end
+  
+      definition.each { |name, prop|
+        prop['value'] = properties[name]
+      }
+      return [200, JSON.generate(definition)]
+    rescue
+      return [400, 'unable to get cluster properties']
+    end
+  end
+
   get '/managec/:cluster/?*' do
     raw_data = request.env["rack.input"].read
     if params[:cluster]
@@ -727,48 +898,6 @@ else
 
 end
 
-def getConfigOptions2(session, cluster_nodes)
-  config_options = {}
-  general_page = []
-#  general_page << ConfigOption.new("Cluster Delay Time", "cluster-delay",  "int", 4, "Seconds") 
-#  general_page << ConfigOption.new("Batch Limit", "cdt",  "int", 4) 
-#  general_page << ConfigOption.new("Default Action Timeout", "cdt",  "int", 4, "Seconds") 
-#  general_page << ConfigOption.new("During timeout should cluster stop all active resources", "res_stop", "radio", "4", "", ["Yes","No"])
-
-#  general_page << ConfigOption.new("PE Error Storage", "res_stop", "radio", "4", "", ["Yes","No"])
-#  general_page << ConfigOption.new("PE Warning Storage", "res_stop", "radio", "4", "", ["Yes","No"])
-#  general_page << ConfigOption.new("PE Input Storage", "res_stop", "radio", "4", "", ["Yes","No"])
-  config_options["general"] = general_page
-
-  pacemaker_page = []
-  pacemaker_page << ConfigOption.new("Batch Limit", "batch-limit",  "int", 4, "jobs", {},  'The number of jobs that pacemaker is allowed to execute in parallel. The "correct" value will depend on the speed and load of your network and cluster nodes.')
-  pacemaker_page << ConfigOption.new("No Quorum Policy", "no-quorum-policy",  "dropdown","" ,"", {"ignore" => "Ignore","freeze" => "Freeze", "stop" => "Stop", "suicide" => "Suicide"}, 'What to do when the cluster does not have quorum. Allowed values:
-  * ignore - continue all resource management
-  * freeze - continue resource management, but don\'t recover resources from nodes not in the affected partition
-  * stop - stop all resources in the affected cluster partition
-  * suicide - fence all nodes in the affected cluster partition')
-  pacemaker_page << ConfigOption.new("Symmetric", "symmetric-cluster", "check",nil ,nil,nil,'Can all resources run on any node by default?')
-  pacemaker_page << ConfigOption.new("Stonith Enabled", "stonith-enabled", "check",nil,nil,nil,'Should failed nodes and nodes with resources that can\'t be stopped be shot? If you value your data, set up a STONITH device and enable this.
-If checked, the cluster will refuse to start resources unless one or more STONITH resources have been configured also.')
-  pacemaker_page << ConfigOption.new("Stonith Action", "stonith-action",  "dropdown","" ,"", {"reboot" => "Reboot","off" => "Off", "poweroff" => "Poweroff"},'Action to send to STONITH device. Allowed values: reboot, off. The value poweroff is also allowed, but is only used for legacy devices.') 
-  pacemaker_page << ConfigOption.new("Cluster Delay", "cluster-delay",  "int", 4,nil,nil,'Round trip delay over the network (excluding action execution). The "correct" value will depend on the speed and load of your network and cluster nodes.') 
-  pacemaker_page << ConfigOption.new("Stop Orphan Resources", "stop-orphan-resources", "check",nil,nil,nil,'Should deleted resources be stopped?')
-  pacemaker_page << ConfigOption.new("Stop Orphan Actions", "stop-orphan-actions", "check",nil,nil,nil,'Should deleted actions be cancelled?'
-                                    )
-  pacemaker_page << ConfigOption.new("Start Failure is Fatal", "start-failure-is-fatal", "check",nil,nil,nil,'When unchecked, the cluster will instead use the resource\'s failcount and value for resource-failure-stickiness.')
-  pacemaker_page << ConfigOption.new("PE Error Storage", "pe-error-series-max", "int", "4",nil,nil,'The number of policy engine (PE) inputs resulting in ERRORs to save. Used when reporting problems.')
-  pacemaker_page << ConfigOption.new("PE Warning Storage", "pe-warn-series-max", "int", "4",nil,nil,'The number of PE inputs resulting in WARNINGs to save. Used when reporting problems.')
-  pacemaker_page << ConfigOption.new("PE Input Storage", "pe-input-series-max", "int", "4",nil,nil,'The number of "normal" PE inputs to save. Used when reporting problems.')
-  pacemaker_page << ConfigOption.new("Enable ACLs", "enable-acl", "check", nil,nil,nil,'Should pacemaker use ACLs to determine access to cluster')
-  config_options["pacemaker"] = pacemaker_page
-
-  allconfigoptions = []
-  config_options.each { |i,k| k.each { |j| allconfigoptions << j } }
-  ConfigOption.getDefaultValues(allconfigoptions)
-  ConfigOption.loadValues(session, allconfigoptions, cluster_nodes)
-  return config_options
-end
-
 class Node
   attr_accessor :active, :id, :name, :hostname
 
@@ -777,114 +906,6 @@ class Node
   end
 end
 
-
-class ConfigOption
-  attr_accessor :name, :configname, :type, :size, :units, :options, :default, :value, :desc
-  def initialize(name, configname, type="str", size = 10, units = "", options = [], desc = "")
-    @name = name
-    @configname = configname
-    @type = type
-    @size = size
-    @units = units
-    @options = options
-    @desc = desc
-  end
-
-  def self.loadValues(session, cos, node_list)
-    code, output = send_nodes_request_with_token(session, node_list, "get_cib")
-    $logger.info(code)
-    if code != 200
-      $logger.info "Error: unable to load cib"
-      $logger.info output
-      return
-    end
-
-    doc = REXML::Document.new(output)
-
-    cos.each {|co|
-      prop_found = false
-      doc.elements.each("cib/configuration/crm_config/cluster_property_set/nvpair[@name='#{co.configname}']") { |e|
-        co.value = e.attributes["value"]
-        prop_found = true
-      }
-      if prop_found == false
-        co.value = co.default
-      end
-    }
-  end
-
-  def self.getDefaultValues(cos)
-    [PENGINE, CIB_BINARY].each { |command|
-      metadata = `#{command} metadata`
-      begin
-        doc = REXML::Document.new(metadata)
-        cos.each { |co|
-          doc.elements.each("resource-agent/parameters/parameter[@name='#{co.configname}']/content") { |e|
-            co.default = e.attributes["default"]
-            break
-          }
-        }
-      rescue
-        $logger.error("Failed to parse #{command} metadata")
-      end
-    }
-  end
-
-  def checked(option)
-    case type
-    when "radio"
-      val = value
-      if option == "Yes"
-        if val == "true"
-          return "checked"
-        end
-      else
-        if val == "false"
-          return "checked"
-        end
-      end
-    when "check"
-      if value == "true" || value == "on"
-        return "checked"
-      else
-        return ""
-      end
-    when "dropdown"
-      if value == option
-        return "selected"
-      end
-    end
-  end
-
-  def html
-    paramname = "config[#{configname}]"
-    hidden_paramname = "hidden[#{configname}]"
-    case type
-    when "int"
-      return "<input name=\"#{paramname}\" value=\"#{value}\" type=text size=#{size}>"
-    when "str"
-      return "<input name=\"#{paramname}\" value=\"#{value}\" type=text size=#{size}>"
-    when "radio"
-      ret = ""
-      options.each {|option|
-        ret += "<input type=radio #{checked(option)} name=\"#{paramname}\" value=\"#{option}\">#{option}"
-      }
-      return ret
-    when "check"
-      ret = "<input type=checkbox name=\"#{paramname}\" " + self.checked(nil) + ">"
-      ret += "<input type=hidden name=\"#{hidden_paramname}\" value=\"off\">"
-      return ret
-    when "dropdown"
-      ret = "<select name=\"#{paramname}\">"
-      options.each {|key, option|
-        ret += "<option #{checked(key)} value=\"#{key}\">#{option}</option>"
-      }
-      ret += "</select>"
-      return ret
-    end
-  end
-end
-
 helpers do
   def h(text)
     Rack::Utils.escape_html(text)
diff --git a/pcsd/public/js/nodes-ember.js b/pcsd/public/js/nodes-ember.js
index 4f33768..d49feb8 100644
--- a/pcsd/public/js/nodes-ember.js
+++ b/pcsd/public/js/nodes-ember.js
@@ -108,7 +108,6 @@ Pcs = Ember.Application.createWithMixins({
       success: function(data) {
         Pcs.resourcesContainer.update(data);
         Pcs.nodesController.update(data);
-        Pcs.settingsController.update(data);
         Pcs.aclsController.update(data);
         Pcs.set("cluster_settings",data.cluster_settings);
         Pcs.set('need_ring1_address', false);
@@ -127,6 +126,7 @@ Pcs = Ember.Application.createWithMixins({
           var cur_resource = self.get('cur_resource');
           var resource_map = self.get('resource_map');
           if (first_run) {
+            refresh_cluster_properties();
             setup_node_links();
             Pcs.nodesController.load_node($('#node_list_row').find('.node_selected').first(),true);
             Pcs.aclsController.load_role($('#acls_list_row').find('.node_selected').first(), true);
@@ -205,6 +205,47 @@ Pcs = Ember.Application.createWithMixins({
   }
 });
 
+Pcs.ValueSelectorComponent = Ember.Component.extend({
+  tagName: 'select',
+  attributeBindings: ['name'],
+  name: null,
+  prompt: "Select one value",
+  show_prompt: true,
+  content: [],
+  value: null,
+  _change: function() {
+    var selectedIndex = this.$()[0].selectedIndex,
+      content = this.get('content'),
+      prompt = this.get('show_prompt');
+
+    if (!content || !content.get('length')) { return; }
+    if (prompt && selectedIndex === 0) { this.set('value', ""); return; }
+
+    if (prompt) { selectedIndex -= 1; }
+    this.set('value', content.objectAt(selectedIndex)['value']);
+  },
+  init: function() {
+    this._super();
+    this.on("change", this, this._change);
+  }
+});
+
+Pcs.ClusterPropertyComponent = Ember.Component.extend({
+  tagName: 'tr',
+  prop: null,
+  attributeBindings: ['name'],
+  boolean_options: [
+    {
+      name: "true",
+      value: "true"
+    },
+    {
+      name: "false",
+      value: "false"
+    }
+  ]
+});
+
 Pcs.UtilizationTableComponent = Ember.Component.extend({
   entity: null,
   type: "node", // node or resource
@@ -1063,8 +1104,47 @@ Pcs.ResourcesRoute = Ember.Route.extend({
 
 Pcs.Setting = Ember.Object.extend({
   name: null,
+  readable_name: null,
+  form_name: function() {
+    return "config[" + this.get("name") + "]";
+  }.property("name"),
   value: null,
-  type: null
+  cur_val: Ember.computed.oneWay('value'),
+  type: null,
+  source: "",
+  default: null,
+  advanced: false,
+  longdesc: "",
+  shortdesc: "",
+  description: function() {
+    var self = this;
+    var desc = $("<div>").text(self.get("shortdesc")).html();
+    if (self.get("longdesc")) {
+      desc += "<br><br>";
+      desc += $("<div>").text(self.get("longdesc")).html();
+    }
+    desc += "<br><br>";
+    desc += $("<div>").text("Default value: " + self.get("default")).html();
+    return desc;
+  }.property("longdesc", "shortdesc"),
+  is_boolean: function() {
+    return (this.get("type") == "boolean");
+  }.property("type"),
+  is_enum: function() {
+    return (this.get("type") == "enum");
+  }.property("type"),
+  enum: [],
+  enum_show: function() {
+    var self = this;
+    var out = [];
+    $.each(self.get("enum"), function(_, val) {
+      out.push({
+        name: val,
+        value: val
+      });
+    });
+    return out;
+  }.property("enum.@each")
 });
 
 Pcs.Clusternode = Ember.Object.extend({
@@ -1663,24 +1743,74 @@ Pcs.aclsController = Ember.ArrayController.createWithMixins({
   }
 });
 
-Pcs.settingsController = Ember.ArrayController.create({
-  content: [],
-  update: function(data) {
+Pcs.settingsController = Ember.Controller.create({
+  properties: [],
+  filtered: [],
+  show_advanced: false,
+  filter: "",
+  update: function(properties_definition) {
     var self = this;
-    var settings = {};
-    self.set('content',[]);
-    if (data["cluster_settings"]) {
-      $.each(data["cluster_settings"], function(k2, v2) {
-        var setting = Pcs.Setting.create({
-          name: k2,
-          value: v2
-        });
-        self.pushObject(setting);
-      });
-    }
+    var new_properties = [];
+    var property;
+    var value;
+    $.each(properties_definition, function(_, prop_def) {
+      property = Pcs.Setting.create(prop_def);
+      value = property.get("value");
+      if (value) {
+        switch (property.get("type")) {
+          case "boolean":
+            value = (is_cib_true(value)) ? "true" : "false";
+            break;
+          case "enum":
+            if (property.get("enum").indexOf(value) == -1) {
+              property.get("enum").push(value);
+            }
+        }
+        property.set("value", value);
+      }
+      new_properties.pushObject(property);
+    });
+    // first basic and then advanced
+    self.set("properties", new_properties.sort(function(a,b) {
+      if (!a.get("advanced") && b.get("advanced")) {
+        return -1;
+      } else if (a.get("advanced") && !b.get("advanced")) {
+        return 1;
+      } else {
+        return a.get('name').localeCompare(b.get('name'));
+      }
+    }));
   }
 });
 
+Pcs.settingsController.reopen({
+  filtered: function() {
+    var self = this;
+    var substr = self.get("filter").toLowerCase();
+    
+    var to_show = [];
+    $.each(self.get("properties"), function(_, e) {
+      if (self.get("show_advanced")) {
+        to_show.pushObject(e);
+      } else if (!e.get("advanced")) {
+        to_show.pushObject(e);
+      }
+    });
+
+    if (!substr) {
+      return to_show;
+    }
+    
+    var filtered = [];
+    $.each(to_show, function(_, e) {
+      if (e.get("name").toLowerCase().includes(substr) || e.get("readable_name").toLowerCase().includes(substr)) {
+        filtered.pushObject(e);
+      }
+    });
+    return filtered;
+  }.property("properties", "filter", "show_advanced")
+});
+
 Pcs.selectedNodeController = Ember.Object.createWithMixins({
   node: null,
   reset: function() {
diff --git a/pcsd/public/js/pcsd.js b/pcsd/public/js/pcsd.js
index 63a7652..926e854 100644
--- a/pcsd/public/js/pcsd.js
+++ b/pcsd/public/js/pcsd.js
@@ -1780,23 +1780,54 @@ function remove_acl_item(id,item) {
   });
 }
 
-function update_cluster_settings(form) {
-  var data = form.serialize();
-  $('html, body, form, :input, :submit').css("cursor","wait");
+function update_cluster_settings() {
+  $("#cluster_properties button").prop("disabled", true);
+  var data = {
+    'hidden[hidden_input]': null // this is needed for backward compatibility 
+  };
+  $.each(Pcs.settingsController.get("properties"), function(_, prop) {
+    data[prop.get("form_name")] = prop.get("cur_val");
+  });
+  show_loading_screen();
   $.ajax({
     type: 'POST',
     url: get_cluster_remote_url() + 'update_cluster_settings',
     data: data,
     timeout: pcs_timeout,
     success: function() {
-      window.location.reload();
+      refresh_cluster_properties();
     },
     error: function (xhr, status, error) {
       alert(
         "Error updating configuration "
         + ajax_simple_error(xhr, status, error)
       );
-      $('html, body, form, :input, :submit').css("cursor","auto");
+      hide_loading_screen();
+      $("#cluster_properties button").prop("disabled", false);
+    }
+  });
+}
+
+function refresh_cluster_properties() {
+  Pcs.settingsController.set("filter", "");
+  $("#cluster_properties button").prop("disabled", true);
+  $.ajax({
+    url: get_cluster_remote_url() + "cluster_properties",
+    timeout: pcs_timeout,
+    dataType: "json",
+    success: function(data) {
+      Pcs.settingsController.update(data);
+    },
+    error: function (xhr, status, error) {
+      alert(
+        "Unable to get cluster properties: "
+        + ajax_simple_error(xhr, status, error)
+      );
+      Pcs.settingsController.update({});
+    },
+    complete: function() {
+      hide_loading_screen();
+      $("#cluster_properties button").prop("disabled", false);
     }
   });
 }
@@ -2535,3 +2566,20 @@ function is_integer(str) {
   var n = ~~Number(str);
   return String(n) === str;
 }
+
+Ember.Handlebars.helper('selector-helper', function (content, value, place_holder, options) {
+  var out = "";
+  var line;
+  if (place_holder) {
+    out += '<option value="">' + place_holder + '</option>'; 
+  }
+  $.each(content, function(_, opt){
+    line = '<option value="' + opt["value"] + '"';
+    if (value == opt["value"]) {
+      line += ' selected="selected"'
+    }
+    line += ">" + Handlebars.Utils.escapeExpression(opt["name"]) + "</option>";
+    out += line + "\n";
+  });
+  return new Handlebars.SafeString(out);
+});
diff --git a/pcsd/remote.rb b/pcsd/remote.rb
index 4b8505b..d166fde 100644
--- a/pcsd/remote.rb
+++ b/pcsd/remote.rb
@@ -3,6 +3,7 @@ require 'uri'
 require 'open4'
 require 'set'
 require 'timeout'
+require 'rexml/document'
 
 require 'pcs.rb'
 require 'resource.rb'
@@ -65,6 +66,7 @@ def remote(params, request, session)
       :get_cluster_tokens => method(:get_cluster_tokens),
       :save_tokens => method(:save_tokens),
       :add_node_to_cluster => method(:add_node_to_cluster),
+      :get_cluster_properties_definition => method(:get_cluster_properties_definition)
   }
   remote_cmd_with_pacemaker = {
       :resource_start => method(:resource_start),
@@ -1905,63 +1907,43 @@ def add_group(params, request, session)
 end
 
 def update_cluster_settings(params, request, session)
-  settings = params["config"]
-  hidden_settings = params["hidden"]
-  hidden_settings.each{|name,val|
-    found = false
-    settings.each{|name2,val2|
-      if name == name2
-        found = true
-        break
-      end
-    }
-    if not found
-      settings[name] = val
-    end
-  }
-  settings.each { |_, val| val.strip!() }
-
-  binary_settings = []
-  changed_settings = []
-  old_settings = {}
-  getConfigOptions2(
-    PCSAuth.getSuperuserSession(), get_nodes().flatten()
-  ).values().flatten().each { |opt|
-    binary_settings << opt.configname if "check" == opt.type
-    # if we don't know current value of an option, consider it changed
-    next if opt.value.nil?
-    if "check" == opt.type
-      old_settings[opt.configname] = is_cib_true(opt.value)
-    else
-      old_settings[opt.configname] = opt.value
+  properties = params['config']
+  to_update = []
+  current = getAllSettings(session)
+  properties.each { |prop, val|
+    val.strip!
+    if not current.include?(prop) and val != '' # add
+      to_update << prop
+    elsif current.include?(prop) and val == '' # remove
+      to_update << prop
+    elsif current.include?(prop) and current[prop] != val # update
+      to_update << prop
     end
   }
-  settings.each { |key, val|
-    new_val = binary_settings.include?(key) ? is_cib_true(val) : val
-    # if we don't know current value of an option, consider it changed
-    if (not old_settings.key?(key)) or (old_settings[key] != new_val)
-      changed_settings << key.downcase()
-    end
-  }
-  if changed_settings.include?('enable-acl')
+
+  if to_update.count { |x| x.downcase == 'enable-acl' } > 0
     if not allowed_for_local_cluster(session, Permissions::GRANT)
       return 403, 'Permission denied'
     end
   end
-  if changed_settings.count { |x| x != 'enable-acl' } > 0
+  if to_update.count { |x| x.downcase != 'enable-acl' } > 0
     if not allowed_for_local_cluster(session, Permissions::WRITE)
       return 403, 'Permission denied'
     end
   end
 
-  changed_settings.each { |name|
-    val = settings[name]
-    if name == "enable-acl"
-      run_cmd(session, PCS, "property", "set", name + "=" + val, "--force")
-    else
-      run_cmd(session, PCS, "property", "set", name + "=" + val)
+  if to_update.empty?
+    $logger.info('No properties to update')
+  else
+    cmd_args = []
+    to_update.each { |prop|
+      cmd_args << "#{prop.downcase}=#{properties[prop]}"
+    }
+    stdout, stderr, retval = run_cmd(session, PCS, 'property', 'set', *cmd_args)
+    if retval != 0
+      return [400, stderr.join('').gsub(', (use --force to override)', '')]
     end
-  }
+  end
   return [200, "Update Successful"]
 end
 
@@ -2320,3 +2302,16 @@ def set_node_utilization(params, reqest, session)
   end
   return 200
 end
+
+def get_cluster_properties_definition(params, request, session)
+  unless allowed_for_local_cluster(session, Permissions::READ)
+    return 403, 'Permission denied'
+  end
+  stdout, _, retval = run_cmd(
+    session, PCS, 'property', 'get_cluster_properties_definition'
+  )
+  if retval == 0
+    return [200, stdout]
+  end
+  return [400, '{}']
+end
diff --git a/pcsd/views/_configure.erb b/pcsd/views/_configure.erb
index 9331621..421f384 100644
--- a/pcsd/views/_configure.erb
+++ b/pcsd/views/_configure.erb
@@ -14,24 +14,32 @@
 </tr>
 <tr id="configure_list_row" {{bind-attr style="Pcs.configure_page"}}>
   <td id="config" colspan=3>
-    <form>
-      <% @config_options.each { |page, options| %>
-        <table>
-          <% options.each { |co| %>
-            <tr title="<%= h(co.desc) %>">
-              <td class="label"><%= co.name %>:</td>
-              <td><%= co.html %><span class="units"><%= co.units %></span></td>
-            </tr>
-          <% } %>
-        </table>
-      <br>
-      <% } %>
-      <% if @config_options.length != 0 %>
-        <input type="submit" style="margin-left:20px;" class="text_field"
-          onclick="update_cluster_settings($(this).parent('form')); return false;"
-          value="Apply Changes"
-        >
-      <% end %>
+    {{input
+        type="text"
+        value=Pcs.settingsController.filter
+        placeholder="Filter"
+    }}
+    {{#if Pcs.settingsController.show_advanced}}
+      <button onclick="Pcs.settingsController.set('show_advanced', false);">Hide advanced settings</button>
+    {{else}}
+      <button onclick="Pcs.settingsController.set('show_advanced', true);">Show advanced settings</button>
+    {{/if}}
+    <form id="cluster_properties">
+      <table>
+        {{#each property in Pcs.settingsController.filtered}}
+          {{cluster-property prop=property name=property.name}}
+        {{else}}
+        <tr><td>No cluster properties available.</td></tr>
+        {{/each}}
+      </table>
+      {{#if Pcs.settingsController.filtered}}
+        <button onclick="update_cluster_settings(); return false;">
+          Apply Changes
+        </button>
+      {{/if}}
+      <button onclick="show_loading_screen(); refresh_cluster_properties(); return false;">
+        Refresh
+      </button>
     </form>
   </td>
 </tr>
diff --git a/pcsd/views/main.erb b/pcsd/views/main.erb
index 4e6aff3..ae3c478 100644
--- a/pcsd/views/main.erb
+++ b/pcsd/views/main.erb
@@ -551,6 +551,43 @@ Use the 'Add' button to submit the form.">
       {{/if}}
     </table>
   </script>
+
+  <script type="text/x-handlebars" data-template-name="components/value-selector">
+    {{selector-helper content value prompt}}
+  </script>
+
+  <script type="text/x-handlebars" data-template-name="components/cluster-property">
+    <td>
+      <span style="float: left;">
+        {{prop.readable_name}}
+      </span>
+      <span style="margin-left: 0.5em" class="infoicon sprites" {{bind-attr title=prop.description}}></span>
+    </td>
+    <td>
+      {{#if prop.is_boolean}}
+        {{value-selector
+            prompt="(Default)"
+            content=boolean_options
+            value=prop.cur_val
+            name=prop.form_name
+        }}
+      {{else}}{{#if prop.is_enum}}
+        {{value-selector
+            prompt="(Default)"
+            content=prop.enum_show
+            value=prop.cur_val
+            name=prop.form_name
+        }}
+      {{else}}
+      {{input
+          type="text"
+          name=prop.form_name
+          value=prop.cur_val
+          placeholder=prop.default
+      }}
+      {{/if}}{{/if}}
+    </td>
+  </script>
   
   <script type="text/x-handlebars">
 <div id="wrapper">
-- 
1.7.1

